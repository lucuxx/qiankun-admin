{"remainingRequest":"/Users/liuxiang/Desktop/lxx/lxx/blob-server/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/liuxiang/Desktop/lxx/lxx/blob-server/src/components/BackGround.vue?vue&type=script&lang=ts&","dependencies":[{"path":"/Users/liuxiang/Desktop/lxx/lxx/blob-server/src/components/BackGround.vue","mtime":1564729993225},{"path":"/Users/liuxiang/Desktop/lxx/lxx/blob-server/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/liuxiang/Desktop/lxx/lxx/blob-server/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/liuxiang/Desktop/lxx/lxx/blob-server/node_modules/ts-loader/index.js","mtime":499162500000},{"path":"/Users/liuxiang/Desktop/lxx/lxx/blob-server/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/liuxiang/Desktop/lxx/lxx/blob-server/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["\n\n\n\n\n\n\n\nimport {Vue, Component} from 'vue-property-decorator'\n\n@Component\n\nexport default class BackGround extends Vue {\n    mounted() {\n        let sakura_point_vsh: string = `\nuniform mat4 uProjection;\nuniform mat4 uModelview;\nuniform vec3 uResolution;\nuniform vec3 uOffset;\nuniform vec3 uDOF;  //x:focus distance, y:focus radius, z:max radius\nuniform vec3 uFade; //x:start distance, y:half distance, z:near fade start\n\nattribute vec3 aPosition;\nattribute vec3 aEuler;\nattribute vec2 aMisc; //x:size, y:fade\n\nvarying vec3 pposition;\nvarying float psize;\nvarying float palpha;\nvarying float pdist;\n\n//varying mat3 rotMat;\nvarying vec3 normX;\nvarying vec3 normY;\nvarying vec3 normZ;\nvarying vec3 normal;\n\nvarying float diffuse;\nvarying float specular;\nvarying float rstop;\nvarying float distancefade;\n\nvoid main(void) {\n    // Projection is based on vertical angle\n    vec4 pos = uModelview * vec4(aPosition + uOffset, 1.0);\n    gl_Position = uProjection * pos;\n    gl_PointSize = aMisc.x * uProjection[1][1] / -pos.z * uResolution.y * 0.5;\n\n    pposition = pos.xyz;\n    psize = aMisc.x;\n    pdist = length(pos.xyz);\n    palpha = smoothstep(0.0, 1.0, (pdist - 0.1) / uFade.z);\n\n    vec3 elrsn = sin(aEuler);\n    vec3 elrcs = cos(aEuler);\n    mat3 rotx = mat3(\n        1.0, 0.0, 0.0,\n        0.0, elrcs.x, elrsn.x,\n        0.0, -elrsn.x, elrcs.x\n    );\n    mat3 roty = mat3(\n        elrcs.y, 0.0, -elrsn.y,\n        0.0, 1.0, 0.0,\n        elrsn.y, 0.0, elrcs.y\n    );\n    mat3 rotz = mat3(\n        elrcs.z, elrsn.z, 0.0,\n        -elrsn.z, elrcs.z, 0.0,\n        0.0, 0.0, 1.0\n    );\n    mat3 rotmat = rotx * roty * rotz;\n    normal = rotmat[2];\n\n    mat3 trrotm = mat3(\n        rotmat[0][0], rotmat[1][0], rotmat[2][0],\n        rotmat[0][1], rotmat[1][1], rotmat[2][1],\n        rotmat[0][2], rotmat[1][2], rotmat[2][2]\n    );\n    normX = trrotm[0];\n    normY = trrotm[1];\n    normZ = trrotm[2];\n\n    const vec3 lit = vec3(0.6917144638660746, 0.6917144638660746, -0.20751433915982237);\n\n    float tmpdfs = dot(lit, normal);\n    if(tmpdfs < 0.0) {\n        normal = -normal;\n        tmpdfs = dot(lit, normal);\n    }\n    diffuse = 0.4 + tmpdfs;\n\n    vec3 eyev = normalize(-pos.xyz);\n    if(dot(eyev, normal) > 0.0) {\n        vec3 hv = normalize(eyev + lit);\n        specular = pow(max(dot(hv, normal), 0.0), 20.0);\n    }\n    else {\n        specular = 0.0;\n    }\n\n    rstop = clamp((abs(pdist - uDOF.x) - uDOF.y) / uDOF.z, 0.0, 1.0);\n    rstop = pow(rstop, 0.5);\n    //-0.69315 = ln(0.5)\n    distancefade = min(1.0, exp((uFade.x - pdist) * 0.69315 / uFade.y));\n}`;\n        let sakura_point_fsh: string = `\n#ifdef GL_ES\n//precision mediump float;\nprecision highp float;\n#endif\n\nuniform vec3 uDOF;  //x:focus distance, y:focus radius, z:max radius\nuniform vec3 uFade; //x:start distance, y:half distance, z:near fade start\n\nconst vec3 fadeCol = vec3(0.08, 0.03, 0.06);\n\nvarying vec3 pposition;\nvarying float psize;\nvarying float palpha;\nvarying float pdist;\n\n//varying mat3 rotMat;\nvarying vec3 normX;\nvarying vec3 normY;\nvarying vec3 normZ;\nvarying vec3 normal;\n\nvarying float diffuse;\nvarying float specular;\nvarying float rstop;\nvarying float distancefade;\n\nfloat ellipse(vec2 p, vec2 o, vec2 r) {\n    vec2 lp = (p - o) / r;\n    return length(lp) - 1.0;\n}\n\nvoid main(void) {\n    vec3 p = vec3(gl_PointCoord - vec2(0.5, 0.5), 0.0) * 2.0;\n    vec3 d = vec3(0.0, 0.0, -1.0);\n    float nd = normZ.z; //dot(-normZ, d);\n    if(abs(nd) < 0.0001) discard;\n\n    float np = dot(normZ, p);\n    vec3 tp = p + d * np / nd;\n    vec2 coord = vec2(dot(normX, tp), dot(normY, tp));\n\n    //angle = 15 degree\n    const float flwrsn = 0.258819045102521;\n    const float flwrcs = 0.965925826289068;\n    mat2 flwrm = mat2(flwrcs, -flwrsn, flwrsn, flwrcs);\n    vec2 flwrp = vec2(abs(coord.x), coord.y) * flwrm;\n\n    float r;\n    if(flwrp.x < 0.0) {\n        r = ellipse(flwrp, vec2(0.065, 0.024) * 0.5, vec2(0.36, 0.96) * 0.5);\n    }\n    else {\n        r = ellipse(flwrp, vec2(0.065, 0.024) * 0.5, vec2(0.58, 0.96) * 0.5);\n    }\n\n    if(r > rstop) discard;\n\n    vec3 col = mix(vec3(1.0, 0.8, 0.75), vec3(1.0, 0.9, 0.87), r);\n    float grady = mix(0.0, 1.0, pow(coord.y * 0.5 + 0.5, 0.35));\n    col *= vec3(1.0, grady, grady);\n    col *= mix(0.8, 1.0, pow(abs(coord.x), 0.3));\n    col = col * diffuse + specular;\n\n    col = mix(fadeCol, col, distancefade);\n\n    float alpha = (rstop > 0.001)? (0.5 - r / (rstop * 2.0)) : 1.0;\n    alpha = smoothstep(0.0, 1.0, alpha) * palpha;\n\n    gl_FragColor = vec4(col * 0.5, alpha);\n}`;\n        let fx_common_vsh: string = `\nuniform vec3 uResolution;\nattribute vec2 aPosition;\n\nvarying vec2 texCoord;\nvarying vec2 screenCoord;\n\nvoid main(void) {\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n    texCoord = aPosition.xy * 0.5 + vec2(0.5, 0.5);\n    screenCoord = aPosition.xy * vec2(uResolution.z, 1.0);\n}`;\n        let bg_fsh: string = `\n#ifdef GL_ES\n//precision mediump float;\nprecision highp float;\n#endif\n\nuniform vec2 uTimes;\n\nvarying vec2 texCoord;\nvarying vec2 screenCoord;\n\nvoid main(void) {\n    vec3 col;\n    float c;\n    vec2 tmpv = texCoord * vec2(0.8, 1.0) - vec2(0.95, 1.0);\n    c = exp(-pow(length(tmpv) * 1.8, 2.0));\n    col = mix(vec3(0.02, 0.0, 0.03), vec3(0.96, 0.98, 1.0) * 1.5, c);\n    gl_FragColor = vec4(col * 0.5, 1.0);\n}`;\n        let fx_brightbuf_fsh: string = `\n#ifdef GL_ES\n//precision mediump float;\nprecision highp float;\n#endif\nuniform sampler2D uSrc;\nuniform vec2 uDelta;\n\nvarying vec2 texCoord;\nvarying vec2 screenCoord;\n\nvoid main(void) {\n    vec4 col = texture2D(uSrc, texCoord);\n    gl_FragColor = vec4(col.rgb * 2.0 - vec3(0.5), 1.0);\n}`;\n        let fx_dirblur_r4_fsh: string = `\n#ifdef GL_ES\n//precision mediump float;\nprecision highp float;\n#endif\nuniform sampler2D uSrc;\nuniform vec2 uDelta;\nuniform vec4 uBlurDir; //dir(x, y), stride(z, w)\n\nvarying vec2 texCoord;\nvarying vec2 screenCoord;\n\nvoid main(void) {\n    vec4 col = texture2D(uSrc, texCoord);\n    col = col + texture2D(uSrc, texCoord + uBlurDir.xy * uDelta);\n    col = col + texture2D(uSrc, texCoord - uBlurDir.xy * uDelta);\n    col = col + texture2D(uSrc, texCoord + (uBlurDir.xy + uBlurDir.zw) * uDelta);\n    col = col + texture2D(uSrc, texCoord - (uBlurDir.xy + uBlurDir.zw) * uDelta);\n    gl_FragColor = col / 5.0;\n}`;\n        let pp_final_vsh: string = `\nuniform vec3 uResolution;\nattribute vec2 aPosition;\nvarying vec2 texCoord;\nvarying vec2 screenCoord;\nvoid main(void) {\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n    texCoord = aPosition.xy * 0.5 + vec2(0.5, 0.5);\n    screenCoord = aPosition.xy * vec2(uResolution.z, 1.0);\n}`;\n        let pp_final_fsh: string = `\n#ifdef GL_ES\n//precision mediump float;\nprecision highp float;\n#endif\nuniform sampler2D uSrc;\nuniform sampler2D uBloom;\nuniform vec2 uDelta;\nvarying vec2 texCoord;\nvarying vec2 screenCoord;\nvoid main(void) {\n    vec4 srccol = texture2D(uSrc, texCoord) * 2.0;\n    vec4 bloomcol = texture2D(uBloom, texCoord);\n    vec4 col;\n    col = srccol + bloomcol * (vec4(1.0) + srccol);\n    col *= smoothstep(1.0, 0.0, pow(length((texCoord - vec2(0.5)) * 2.0), 1.2) * 0.5);\n    col = pow(col, vec4(0.45454545454545)); //(1.0 / 2.2)\n\n    gl_FragColor = vec4(col.rgb, 1.0);\n    gl_FragColor.a = 1.0;\n}`;\n\n        // Utilities\n        var Vector3: any = {};\n        var Matrix44: any = {};\n        Vector3.create = function(x: any, y: any, z: any) {\n            return {x: x, y: y, z: z};\n        };\n        Vector3.dot = function(v0: any, v1: any) {\n            return v0.x * v1.x + v0.y * v1.y + v0.z * v1.z;\n        };\n        Vector3.cross = function(v: any, v0: any, v1: any) {\n            v.x = v0.y * v1.z - v0.z * v1.y;\n            v.y = v0.z * v1.x - v0.x * v1.z;\n            v.z = v0.x * v1.y - v0.y * v1.x;\n        };\n        Vector3.normalize = function(v: any) {\n            var l: any = v.x * v.x + v.y * v.y + v.z * v.z;\n            if (l > 0.00001) {\n                l = 1.0 / Math.sqrt(l);\n                v.x *= l;\n                v.y *= l;\n                v.z *= l;\n            }\n        };\n        Vector3.arrayForm = function(v: any) {\n            if (v.array) {\n                v.array[0] = v.x;\n                v.array[1] = v.y;\n                v.array[2] = v.z;\n            } else {\n                v.array = new Float32Array([v.x, v.y, v.z]);\n            }\n            return v.array;\n        };\n        Matrix44.createIdentity = function() {\n            return new Float32Array([\n                1.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                1.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                1.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                1.0\n            ]);\n        };\n        Matrix44.loadProjection = function(\n            m: any,\n            aspect: any,\n            vdeg: any,\n            near: any,\n            far: any\n        ) {\n            let h = near * Math.tan(((vdeg * Math.PI) / 180.0) * 0.5) * 2.0;\n            let w = h * aspect;\n\n            m[0] = (2.0 * near) / w;\n            m[1] = 0.0;\n            m[2] = 0.0;\n            m[3] = 0.0;\n\n            m[4] = 0.0;\n            m[5] = (2.0 * near) / h;\n            m[6] = 0.0;\n            m[7] = 0.0;\n\n            m[8] = 0.0;\n            m[9] = 0.0;\n            m[10] = -(far + near) / (far - near);\n            m[11] = -1.0;\n\n            m[12] = 0.0;\n            m[13] = 0.0;\n            m[14] = (-2.0 * far * near) / (far - near);\n            m[15] = 0.0;\n        };\n        Matrix44.loadLookAt = function(m: any, vpos: any, vlook: any, vup: any) {\n            let frontv = Vector3.create(\n                vpos.x - vlook.x,\n                vpos.y - vlook.y,\n                vpos.z - vlook.z\n            );\n            Vector3.normalize(frontv);\n            let sidev = Vector3.create(1.0, 0.0, 0.0);\n            Vector3.cross(sidev, vup, frontv);\n            Vector3.normalize(sidev);\n            let topv = Vector3.create(1.0, 0.0, 0.0);\n            Vector3.cross(topv, frontv, sidev);\n            Vector3.normalize(topv);\n\n            m[0] = sidev.x;\n            m[1] = topv.x;\n            m[2] = frontv.x;\n            m[3] = 0.0;\n\n            m[4] = sidev.y;\n            m[5] = topv.y;\n            m[6] = frontv.y;\n            m[7] = 0.0;\n\n            m[8] = sidev.z;\n            m[9] = topv.z;\n            m[10] = frontv.z;\n            m[11] = 0.0;\n\n            m[12] = -(vpos.x * m[0] + vpos.y * m[4] + vpos.z * m[8]);\n            m[13] = -(vpos.x * m[1] + vpos.y * m[5] + vpos.z * m[9]);\n            m[14] = -(vpos.x * m[2] + vpos.y * m[6] + vpos.z * m[10]);\n            m[15] = 1.0;\n        };\n\n        //\n        var timeInfo: any = {\n            start: 0,\n            prev: 0, // Date\n            delta: 0,\n            elapsed: 0 // Number(sec)\n        };\n\n        //\n        var gl: any;\n        var renderSpec: any = {\n            width: 0,\n            height: 0,\n            aspect: 1,\n            array: new Float32Array(3),\n            halfWidth: 0,\n            halfHeight: 0,\n            halfArray: new Float32Array(3)\n            // and some render targets. see setViewport()\n        };\n        renderSpec.setSize = function(w: any, h: any) {\n            renderSpec.width = w;\n            renderSpec.height = h;\n            renderSpec.aspect = renderSpec.width / renderSpec.height;\n            renderSpec.array[0] = renderSpec.width;\n            renderSpec.array[1] = renderSpec.height;\n            renderSpec.array[2] = renderSpec.aspect;\n\n            renderSpec.halfWidth = Math.floor(w / 2);\n            renderSpec.halfHeight = Math.floor(h / 2);\n            renderSpec.halfArray[0] = renderSpec.halfWidth;\n            renderSpec.halfArray[1] = renderSpec.halfHeight;\n            renderSpec.halfArray[2] = renderSpec.halfWidth / renderSpec.halfHeight;\n        };\n\n        function deleteRenderTarget(rt: any) {\n            gl.deleteFramebuffer(rt.frameBuffer);\n            gl.deleteRenderbuffer(rt.renderBuffer);\n            gl.deleteTexture(rt.texture);\n        }\n\n        function createRenderTarget(w: any, h: any) {\n            var ret: any = {\n                width: w,\n                height: h,\n                sizeArray: new Float32Array([w, h, w / h]),\n                dtxArray: new Float32Array([1.0 / w, 1.0 / h])\n            };\n            ret.frameBuffer = gl.createFramebuffer();\n            ret.renderBuffer = gl.createRenderbuffer();\n            ret.texture = gl.createTexture();\n\n            gl.bindTexture(gl.TEXTURE_2D, ret.texture);\n            gl.texImage2D(\n                gl.TEXTURE_2D,\n                0,\n                gl.RGBA,\n                w,\n                h,\n                0,\n                gl.RGBA,\n                gl.UNSIGNED_BYTE,\n                null\n            );\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n\n            gl.bindFramebuffer(gl.FRAMEBUFFER, ret.frameBuffer);\n            gl.framebufferTexture2D(\n                gl.FRAMEBUFFER,\n                gl.COLOR_ATTACHMENT0,\n                gl.TEXTURE_2D,\n                ret.texture,\n                0\n            );\n\n            gl.bindRenderbuffer(gl.RENDERBUFFER, ret.renderBuffer);\n            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, w, h);\n            gl.framebufferRenderbuffer(\n                gl.FRAMEBUFFER,\n                gl.DEPTH_ATTACHMENT,\n                gl.RENDERBUFFER,\n                ret.renderBuffer\n            );\n\n            gl.bindTexture(gl.TEXTURE_2D, null);\n            gl.bindRenderbuffer(gl.RENDERBUFFER, null);\n            gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n            return ret;\n        }\n\n        function compileShader(shtype: any, shsrc: any) {\n            var retsh: any = gl.createShader(shtype);\n\n            gl.shaderSource(retsh, shsrc);\n            gl.compileShader(retsh);\n\n            if (!gl.getShaderParameter(retsh, gl.COMPILE_STATUS)) {\n                var errlog: any = gl.getShaderInfoLog(retsh);\n                gl.deleteShader(retsh);\n                console.error(errlog);\n                return null;\n            }\n            return retsh;\n        }\n\n        function createShader(\n            vtxsrc: any,\n            frgsrc: any,\n            uniformlist: any,\n            attrlist: any\n        ) {\n            var vsh: any = compileShader(gl.VERTEX_SHADER, vtxsrc);\n            var fsh: any = compileShader(gl.FRAGMENT_SHADER, frgsrc);\n\n            if (vsh == null || fsh == null) {\n                return null;\n            }\n\n            var prog: any = gl.createProgram();\n            gl.attachShader(prog, vsh);\n            gl.attachShader(prog, fsh);\n\n            gl.deleteShader(vsh);\n            gl.deleteShader(fsh);\n\n            gl.linkProgram(prog);\n            if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {\n                var errlog: any = gl.getProgramInfoLog(prog);\n                console.error(errlog);\n                return null;\n            }\n\n            if (uniformlist) {\n                prog.uniforms = {};\n                for (var i = 0; i < uniformlist.length; i++) {\n                    prog.uniforms[uniformlist[i]] = gl.getUniformLocation(\n                        prog,\n                        uniformlist[i]\n                    );\n                }\n            }\n\n            if (attrlist) {\n                prog.attributes = {};\n                for (let i = 0; i < attrlist.length; i++) {\n                    let attr = attrlist[i];\n                    prog.attributes[attr] = gl.getAttribLocation(prog, attr);\n                }\n            }\n\n            return prog;\n        }\n\n        function useShader(prog: any) {\n            gl.useProgram(prog);\n            for (let attr in prog.attributes) {\n                gl.enableVertexAttribArray(prog.attributes[attr]);\n            }\n        }\n\n        function unuseShader(prog: any) {\n            for (let attr in prog.attributes) {\n                gl.disableVertexAttribArray(prog.attributes[attr]);\n            }\n            gl.useProgram(null);\n        }\n\n        /////\n        var projection: any = {\n            angle: 60,\n            nearfar: new Float32Array([0.1, 100.0]),\n            matrix: Matrix44.createIdentity()\n        };\n        var camera: any = {\n            position: Vector3.create(0, 0, 100),\n            lookat: Vector3.create(0, 0, 0),\n            up: Vector3.create(0, 1, 0),\n            dof: Vector3.create(10.0, 4.0, 8.0),\n            matrix: Matrix44.createIdentity()\n        };\n\n        var pointFlower: any = {};\n        // var meshFlower = {};\n        var sceneStandBy: any = false;\n\n        var BlossomParticle: any = function() {\n            this.velocity = new Array(3);\n            this.rotation = new Array(3);\n            this.position = new Array(3);\n            this.euler = new Array(3);\n            this.size = 1.0;\n            this.alpha = 1.0;\n            this.zkey = 0.0;\n        };\n\n        BlossomParticle.prototype.setVelocity = function(\n            vx: any,\n            vy: any,\n            vz: any\n        ) {\n            this.velocity[0] = vx;\n            this.velocity[1] = vy;\n            this.velocity[2] = vz;\n        };\n\n        BlossomParticle.prototype.setRotation = function(\n            rx: any,\n            ry: any,\n            rz: any\n        ) {\n            this.rotation[0] = rx;\n            this.rotation[1] = ry;\n            this.rotation[2] = rz;\n        };\n\n        BlossomParticle.prototype.setPosition = function(\n            nx: any,\n            ny: any,\n            nz: any\n        ) {\n            this.position[0] = nx;\n            this.position[1] = ny;\n            this.position[2] = nz;\n        };\n\n        BlossomParticle.prototype.setEulerAngles = function(\n            rx: any,\n            ry: any,\n            rz: any\n        ) {\n            this.euler[0] = rx;\n            this.euler[1] = ry;\n            this.euler[2] = rz;\n        };\n\n        BlossomParticle.prototype.setSize = function(s: any) {\n            this.size = s;\n        };\n\n        BlossomParticle.prototype.update = function(dt: any, et: any) {\n            this.position[0] += this.velocity[0] * dt;\n            this.position[1] += this.velocity[1] * dt;\n            this.position[2] += this.velocity[2] * dt;\n\n            this.euler[0] += this.rotation[0] * dt;\n            this.euler[1] += this.rotation[1] * dt;\n            this.euler[2] += this.rotation[2] * dt;\n        };\n\n        function createPointFlowers() {\n            // get point sizes\n            var prm: any = gl.getParameter(gl.ALIASED_POINT_SIZE_RANGE);\n            renderSpec.pointSize = {min: prm[0], max: prm[1]};\n\n            var vtxsrc: any = sakura_point_vsh;\n            var frgsrc: any = sakura_point_fsh;\n\n            pointFlower.program = createShader(\n                vtxsrc,\n                frgsrc,\n                [\n                    \"uProjection\",\n                    \"uModelview\",\n                    \"uResolution\",\n                    \"uOffset\",\n                    \"uDOF\",\n                    \"uFade\"\n                ],\n                [\"aPosition\", \"aEuler\", \"aMisc\"]\n            );\n\n            useShader(pointFlower.program);\n            pointFlower.offset = new Float32Array([0.0, 0.0, 0.0]);\n            pointFlower.fader = Vector3.create(0.0, 10.0, 0.0);\n\n            // paramerters: velocity[3], rotate[3]\n            pointFlower.numFlowers = 1600;\n            pointFlower.particles = new Array(pointFlower.numFlowers);\n            // vertex attributes {position[3], euler_xyz[3], size[1]}\n            pointFlower.dataArray = new Float32Array(\n                pointFlower.numFlowers * (3 + 3 + 2)\n            );\n            pointFlower.positionArrayOffset = 0;\n            pointFlower.eulerArrayOffset = pointFlower.numFlowers * 3;\n            pointFlower.miscArrayOffset = pointFlower.numFlowers * 6;\n\n            pointFlower.buffer = gl.createBuffer();\n            gl.bindBuffer(gl.ARRAY_BUFFER, pointFlower.buffer);\n            gl.bufferData(gl.ARRAY_BUFFER, pointFlower.dataArray, gl.DYNAMIC_DRAW);\n            gl.bindBuffer(gl.ARRAY_BUFFER, null);\n\n            unuseShader(pointFlower.program);\n\n            for (let i = 0; i < pointFlower.numFlowers; i++) {\n                pointFlower.particles[i] = new BlossomParticle();\n            }\n        }\n\n        function initPointFlowers() {\n            //area\n            pointFlower.area = Vector3.create(20.0, 20.0, 20.0);\n            pointFlower.area.x = pointFlower.area.y * renderSpec.aspect;\n\n            pointFlower.fader.x = 10.0; //env fade start\n            pointFlower.fader.y = pointFlower.area.z; //env fade half\n            pointFlower.fader.z = 0.1; //near fade start\n\n            //particles\n            var PI2: any = Math.PI * 2.0;\n            var tmpv3: any = Vector3.create(0, 0, 0);\n            var tmpv: any = 0;\n            var symmetryrand: any = function() {\n                return Math.random() * 2.0 - 1.0;\n            };\n            for (let i = 0; i < pointFlower.numFlowers; i++) {\n                let tmpprtcl = pointFlower.particles[i];\n\n                //velocity\n                tmpv3.x = symmetryrand() * 0.3 + 0.8;\n                tmpv3.y = symmetryrand() * 0.2 - 1.0;\n                tmpv3.z = symmetryrand() * 0.3 + 0.5;\n                Vector3.normalize(tmpv3);\n                tmpv = 2.0 + Math.random() * 1.0;\n                tmpprtcl.setVelocity(tmpv3.x * tmpv, tmpv3.y * tmpv, tmpv3.z * tmpv);\n\n                //rotation\n                tmpprtcl.setRotation(\n                    symmetryrand() * PI2 * 0.5,\n                    symmetryrand() * PI2 * 0.5,\n                    symmetryrand() * PI2 * 0.5\n                );\n\n                //position\n                tmpprtcl.setPosition(\n                    symmetryrand() * pointFlower.area.x,\n                    symmetryrand() * pointFlower.area.y,\n                    symmetryrand() * pointFlower.area.z\n                );\n\n                //euler\n                tmpprtcl.setEulerAngles(\n                    Math.random() * Math.PI * 2.0,\n                    Math.random() * Math.PI * 2.0,\n                    Math.random() * Math.PI * 2.0\n                );\n\n                //size\n                tmpprtcl.setSize(0.9 + Math.random() * 0.1);\n            }\n        }\n\n        function renderPointFlowers() {\n            //update\n            var PI2: any = Math.PI * 2.0;\n            // var limit = [pointFlower.area.x, pointFlower.area.y, pointFlower.area.z];\n            var repeatPos: any = function(prt: any, cmp: any, limit: any) {\n                if (Math.abs(prt.position[cmp]) - prt.size * 0.5 > limit) {\n                    //out of area\n                    if (prt.position[cmp] > 0) {\n                        prt.position[cmp] -= limit * 2.0;\n                    } else {\n                        prt.position[cmp] += limit * 2.0;\n                    }\n                }\n            };\n            var repeatEuler: any = function(prt: any, cmp: any) {\n                prt.euler[cmp] = prt.euler[cmp] % PI2;\n                if (prt.euler[cmp] < 0.0) {\n                    prt.euler[cmp] += PI2;\n                }\n            };\n\n            for (let i = 0; i < pointFlower.numFlowers; i++) {\n                let prtcl = pointFlower.particles[i];\n                prtcl.update(timeInfo.delta, timeInfo.elapsed);\n                repeatPos(prtcl, 0, pointFlower.area.x);\n                repeatPos(prtcl, 1, pointFlower.area.y);\n                repeatPos(prtcl, 2, pointFlower.area.z);\n                repeatEuler(prtcl, 0);\n                repeatEuler(prtcl, 1);\n                repeatEuler(prtcl, 2);\n\n                prtcl.alpha = 1.0; //(pointFlower.area.z - prtcl.position[2]) * 0.5;\n\n                prtcl.zkey =\n                    camera.matrix[2] * prtcl.position[0] +\n                    camera.matrix[6] * prtcl.position[1] +\n                    camera.matrix[10] * prtcl.position[2] +\n                    camera.matrix[14];\n            }\n\n            // sort\n            pointFlower.particles.sort(function(p0: any, p1: any) {\n                return p0.zkey - p1.zkey;\n            });\n\n            // update data\n            var ipos: any = pointFlower.positionArrayOffset;\n            var ieuler: any = pointFlower.eulerArrayOffset;\n            var imisc: any = pointFlower.miscArrayOffset;\n            for (let i = 0; i < pointFlower.numFlowers; i++) {\n                let prtcl = pointFlower.particles[i];\n                pointFlower.dataArray[ipos] = prtcl.position[0];\n                pointFlower.dataArray[ipos + 1] = prtcl.position[1];\n                pointFlower.dataArray[ipos + 2] = prtcl.position[2];\n                ipos += 3;\n                pointFlower.dataArray[ieuler] = prtcl.euler[0];\n                pointFlower.dataArray[ieuler + 1] = prtcl.euler[1];\n                pointFlower.dataArray[ieuler + 2] = prtcl.euler[2];\n                ieuler += 3;\n                pointFlower.dataArray[imisc] = prtcl.size;\n                pointFlower.dataArray[imisc + 1] = prtcl.alpha;\n                imisc += 2;\n            }\n\n            //draw\n            gl.enable(gl.BLEND);\n            //gl.disable(gl.DEPTH_TEST);\n            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n\n            var prog: any = pointFlower.program;\n            useShader(prog);\n\n            gl.uniformMatrix4fv(prog.uniforms.uProjection, false, projection.matrix);\n            gl.uniformMatrix4fv(prog.uniforms.uModelview, false, camera.matrix);\n            gl.uniform3fv(prog.uniforms.uResolution, renderSpec.array);\n            gl.uniform3fv(prog.uniforms.uDOF, Vector3.arrayForm(camera.dof));\n            gl.uniform3fv(prog.uniforms.uFade, Vector3.arrayForm(pointFlower.fader));\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, pointFlower.buffer);\n            gl.bufferData(gl.ARRAY_BUFFER, pointFlower.dataArray, gl.DYNAMIC_DRAW);\n\n            gl.vertexAttribPointer(\n                prog.attributes.aPosition,\n                3,\n                gl.FLOAT,\n                false,\n                0,\n                pointFlower.positionArrayOffset * Float32Array.BYTES_PER_ELEMENT\n            );\n            gl.vertexAttribPointer(\n                prog.attributes.aEuler,\n                3,\n                gl.FLOAT,\n                false,\n                0,\n                pointFlower.eulerArrayOffset * Float32Array.BYTES_PER_ELEMENT\n            );\n            gl.vertexAttribPointer(\n                prog.attributes.aMisc,\n                2,\n                gl.FLOAT,\n                false,\n                0,\n                pointFlower.miscArrayOffset * Float32Array.BYTES_PER_ELEMENT\n            );\n\n            // doubler\n            for (let i = 1; i < 2; i++) {\n                let zpos = i * -2.0;\n                pointFlower.offset[0] = pointFlower.area.x * -1.0;\n                pointFlower.offset[1] = pointFlower.area.y * -1.0;\n                pointFlower.offset[2] = pointFlower.area.z * zpos;\n                gl.uniform3fv(prog.uniforms.uOffset, pointFlower.offset);\n                gl.drawArrays(gl.POINT, 0, pointFlower.numFlowers);\n\n                pointFlower.offset[0] = pointFlower.area.x * -1.0;\n                pointFlower.offset[1] = pointFlower.area.y * 1.0;\n                pointFlower.offset[2] = pointFlower.area.z * zpos;\n                gl.uniform3fv(prog.uniforms.uOffset, pointFlower.offset);\n                gl.drawArrays(gl.POINT, 0, pointFlower.numFlowers);\n\n                pointFlower.offset[0] = pointFlower.area.x * 1.0;\n                pointFlower.offset[1] = pointFlower.area.y * -1.0;\n                pointFlower.offset[2] = pointFlower.area.z * zpos;\n                gl.uniform3fv(prog.uniforms.uOffset, pointFlower.offset);\n                gl.drawArrays(gl.POINT, 0, pointFlower.numFlowers);\n\n                pointFlower.offset[0] = pointFlower.area.x * 1.0;\n                pointFlower.offset[1] = pointFlower.area.y * 1.0;\n                pointFlower.offset[2] = pointFlower.area.z * zpos;\n                gl.uniform3fv(prog.uniforms.uOffset, pointFlower.offset);\n                gl.drawArrays(gl.POINT, 0, pointFlower.numFlowers);\n            }\n\n            //main\n            pointFlower.offset[0] = 0.0;\n            pointFlower.offset[1] = 0.0;\n            pointFlower.offset[2] = 0.0;\n            gl.uniform3fv(prog.uniforms.uOffset, pointFlower.offset);\n            gl.drawArrays(gl.POINT, 0, pointFlower.numFlowers);\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, null);\n            unuseShader(prog);\n\n            gl.enable(gl.DEPTH_TEST);\n            gl.disable(gl.BLEND);\n        }\n\n        // effects\n        //common util\n        function createEffectProgram(\n            vtxsrc: any,\n            frgsrc: any,\n            exunifs: any,\n            exattrs: any\n        ) {\n            var ret: any = {};\n            var unifs: any = [\"uResolution\", \"uSrc\", \"uDelta\"];\n            if (exunifs) {\n                unifs = unifs.concat(exunifs);\n            }\n            var attrs: any = [\"aPosition\"];\n            if (exattrs) {\n                attrs = attrs.concat(exattrs);\n            }\n\n            ret.program = createShader(vtxsrc, frgsrc, unifs, attrs);\n            useShader(ret.program);\n\n            ret.dataArray = new Float32Array([\n                -1.0,\n                -1.0,\n                1.0,\n                -1.0,\n                -1.0,\n                1.0,\n                1.0,\n                1.0\n            ]);\n            ret.buffer = gl.createBuffer();\n            gl.bindBuffer(gl.ARRAY_BUFFER, ret.buffer);\n            gl.bufferData(gl.ARRAY_BUFFER, ret.dataArray, gl.STATIC_DRAW);\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, null);\n            unuseShader(ret.program);\n\n            return ret;\n        }\n\n        function useEffect(fxobj: any, srctex: any) {\n            var prog: any = fxobj.program;\n            useShader(prog);\n            gl.uniform3fv(prog.uniforms.uResolution, renderSpec.array);\n\n            if (srctex != null) {\n                gl.uniform2fv(prog.uniforms.uDelta, srctex.dtxArray);\n                gl.uniform1i(prog.uniforms.uSrc, 0);\n\n                gl.activeTexture(gl.TEXTURE0);\n                gl.bindTexture(gl.TEXTURE_2D, srctex.texture);\n            }\n        }\n\n        function drawEffect(fxobj: any) {\n            gl.bindBuffer(gl.ARRAY_BUFFER, fxobj.buffer);\n            gl.vertexAttribPointer(\n                fxobj.program.attributes.aPosition,\n                2,\n                gl.FLOAT,\n                false,\n                0,\n                0\n            );\n            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n        }\n\n        function unuseEffect(fxobj: any) {\n            unuseShader(fxobj.program);\n        }\n\n        var effectLib: any = {};\n\n        function createEffectLib() {\n            var vtxsrc: any, frgsrc: any;\n            //common\n            var cmnvtxsrc: any = fx_common_vsh;\n\n            //background\n            frgsrc = bg_fsh;\n            effectLib.sceneBg = createEffectProgram(\n                cmnvtxsrc,\n                frgsrc,\n                [\"uTimes\"],\n                null\n            );\n\n            // make brightpixels buffer\n            frgsrc = fx_brightbuf_fsh;\n            effectLib.mkBrightBuf = createEffectProgram(\n                cmnvtxsrc,\n                frgsrc,\n                null,\n                null\n            );\n\n            // direction blur\n            frgsrc = fx_dirblur_r4_fsh;\n            effectLib.dirBlur = createEffectProgram(\n                cmnvtxsrc,\n                frgsrc,\n                [\"uBlurDir\"],\n                null\n            );\n\n            //final composite\n            vtxsrc = pp_final_vsh;\n            frgsrc = pp_final_fsh;\n            // console.log('frgsrc :',frgsrc )\n            effectLib.finalComp = createEffectProgram(\n                vtxsrc,\n                frgsrc,\n                [\"uBloom\"],\n                null\n            );\n        }\n\n        // background\n        function createBackground() {\n            //console.log(\"create background\");\n        }\n\n        function initBackground() {\n            //console.log(\"init background\");\n        }\n\n        function renderBackground() {\n            gl.disable(gl.DEPTH_TEST);\n\n            useEffect(effectLib.sceneBg, null);\n            gl.uniform2f(\n                effectLib.sceneBg.program.uniforms.uTimes,\n                timeInfo.elapsed,\n                timeInfo.delta\n            );\n            drawEffect(effectLib.sceneBg);\n            unuseEffect(effectLib.sceneBg);\n\n            gl.enable(gl.DEPTH_TEST);\n        }\n\n        // post process\n        // var postProcess = {};\n        function createPostProcess() {\n            //console.log(\"create post process\");\n        }\n\n        function initPostProcess() {\n            //console.log(\"init post process\");\n        }\n\n        function renderPostProcess() {\n            // gl.enable(gl.TEXTURE_2D);\n            gl.disable(gl.DEPTH_TEST);\n            var bindRT: any = function(rt: any, isclear: any) {\n                gl.bindFramebuffer(gl.FRAMEBUFFER, rt.frameBuffer);\n                gl.viewport(0, 0, rt.width, rt.height);\n                if (isclear) {\n                    gl.clearColor(0, 0, 0, 0);\n                    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n                }\n            };\n\n            //make bright buff\n            bindRT(renderSpec.wHalfRT0, true);\n            useEffect(effectLib.mkBrightBuf, renderSpec.mainRT);\n            drawEffect(effectLib.mkBrightBuf);\n            unuseEffect(effectLib.mkBrightBuf);\n\n            // make bloom\n            for (let i = 0; i < 2; i++) {\n                let p = 1.5 + 1 * i;\n                let s = 2.0 + 1 * i;\n                bindRT(renderSpec.wHalfRT1, true);\n                useEffect(effectLib.dirBlur, renderSpec.wHalfRT0);\n                gl.uniform4f(\n                    effectLib.dirBlur.program.uniforms.uBlurDir,\n                    p,\n                    0.0,\n                    s,\n                    0.0\n                );\n                drawEffect(effectLib.dirBlur);\n                unuseEffect(effectLib.dirBlur);\n\n                bindRT(renderSpec.wHalfRT0, true);\n                useEffect(effectLib.dirBlur, renderSpec.wHalfRT1);\n                gl.uniform4f(\n                    effectLib.dirBlur.program.uniforms.uBlurDir,\n                    0.0,\n                    p,\n                    0.0,\n                    s\n                );\n                drawEffect(effectLib.dirBlur);\n                unuseEffect(effectLib.dirBlur);\n            }\n\n            //display\n            gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n            gl.viewport(0, 0, renderSpec.width, renderSpec.height);\n            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n\n            useEffect(effectLib.finalComp, renderSpec.mainRT);\n            gl.uniform1i(effectLib.finalComp.program.uniforms.uBloom, 1);\n            gl.activeTexture(gl.TEXTURE1);\n            gl.bindTexture(gl.TEXTURE_2D, renderSpec.wHalfRT0.texture);\n            drawEffect(effectLib.finalComp);\n            unuseEffect(effectLib.finalComp);\n\n            gl.enable(gl.DEPTH_TEST);\n        }\n\n        /////\n        // var SceneEnv = {};\n        function createScene() {\n            createEffectLib();\n            createBackground();\n            createPointFlowers();\n            createPostProcess();\n            sceneStandBy = true;\n        }\n\n        function initScene() {\n            initBackground();\n            initPointFlowers();\n            initPostProcess();\n\n            //camera.position.z = 17.320508;\n            camera.position.z = pointFlower.area.z + projection.nearfar[0];\n            projection.angle =\n                ((Math.atan2(\n                    pointFlower.area.y,\n                    camera.position.z + pointFlower.area.z\n                    ) *\n                    180.0) /\n                    Math.PI) *\n                2.0;\n            Matrix44.loadProjection(\n                projection.matrix,\n                renderSpec.aspect,\n                projection.angle,\n                projection.nearfar[0],\n                projection.nearfar[1]\n            );\n        }\n\n        function renderScene() {\n            //draw\n            Matrix44.loadLookAt(\n                camera.matrix,\n                camera.position,\n                camera.lookat,\n                camera.up\n            );\n\n            gl.enable(gl.DEPTH_TEST);\n\n            //gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n            gl.bindFramebuffer(gl.FRAMEBUFFER, renderSpec.mainRT.frameBuffer);\n            gl.viewport(0, 0, renderSpec.mainRT.width, renderSpec.mainRT.height);\n            gl.clearColor(0.005, 0, 0.05, 0);\n            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n\n            renderBackground();\n            renderPointFlowers();\n            renderPostProcess();\n        }\n\n        /////\n        function onResize(e: any) {\n            makeCanvasFullScreen(document.getElementById(\"sakura\"));\n            setViewports();\n            if (sceneStandBy) {\n                initScene();\n            }\n        }\n\n        function setViewports() {\n            renderSpec.setSize(gl.canvas.width, gl.canvas.height);\n\n            gl.clearColor(0.2, 0.2, 0.5, 1.0);\n            gl.viewport(0, 0, renderSpec.width, renderSpec.height);\n\n            var rtfunc: any = function(rtname: any, rtw: any, rth: any) {\n                var rt: any = renderSpec[rtname];\n                if (rt) {\n                    deleteRenderTarget(rt);\n                }\n                renderSpec[rtname] = createRenderTarget(rtw, rth);\n            };\n            rtfunc(\"mainRT\", renderSpec.width, renderSpec.height);\n            rtfunc(\"wFullRT0\", renderSpec.width, renderSpec.height);\n            rtfunc(\"wFullRT1\", renderSpec.width, renderSpec.height);\n            rtfunc(\"wHalfRT0\", renderSpec.halfWidth, renderSpec.halfHeight);\n            rtfunc(\"wHalfRT1\", renderSpec.halfWidth, renderSpec.halfHeight);\n        }\n\n        function render() {\n            renderScene();\n        }\n\n        var animating: boolean = true;\n\n        function animate() {\n            var curdate: any = new Date();\n            timeInfo.elapsed = (curdate - timeInfo.start) / 1000.0;\n            timeInfo.delta = (curdate - timeInfo.prev) / 1000.0;\n            timeInfo.prev = curdate;\n\n            if (animating) {\n                requestAnimationFrame(animate);\n            }\n            render();\n        }\n\n        function makeCanvasFullScreen(canvas: any) {\n            var b: any = document.body;\n            var d: any = document.documentElement;\n            let fullw = Math.max(\n                b.clientWidth,\n                b.scrollWidth,\n                d.scrollWidth,\n                d.clientWidth\n            );\n            let fullh = Math.max(\n                b.clientHeight,\n                b.scrollHeight,\n                d.scrollHeight,\n                d.clientHeight\n            );\n            canvas.width = fullw;\n            canvas.height = fullh;\n        }\n\n        // 保证每次都执行\n        var canvas: any = document.getElementById(\"sakura\");\n        try {\n            makeCanvasFullScreen(canvas);\n            gl = canvas.getContext(\"experimental-webgl\");\n        } catch (e) {\n            alert(\"WebGL not supported.\" + e);\n            console.error(e);\n            return;\n        }\n\n        window.addEventListener(\"resize\", onResize);\n\n        setViewports();\n        createScene();\n        initScene();\n\n        timeInfo.start = new Date();\n        timeInfo.prev = timeInfo.start;\n        animate();\n\n        //set window.requestAnimationFrame\n        (function(w: any, r: any) {\n            w[\"r\" + r] =\n                w[\"r\" + r] ||\n                w[\"webkitR\" + r] ||\n                w[\"mozR\" + r] ||\n                w[\"msR\" + r] ||\n                w[\"oR\" + r] ||\n                function(c: any) {\n                    w.setTimeout(c, 1000 / 60);\n                };\n        })(window, \"equestAnimationFrame\");\n    }\n}\n",{"version":3,"sources":["BackGround.vue"],"names":[],"mappings":";;;;;;;;AAQA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"BackGround.vue","sourceRoot":"src/components","sourcesContent":["<template>\n    <section class=\"BackGround\">\n        <!--        满屏落花效果-->\n        <canvas id=\"sakura\"></canvas>\n    </section>\n</template>\n\n<script lang=\"ts\">\n    import {Vue, Component} from 'vue-property-decorator'\n\n    @Component\n\n    export default class BackGround extends Vue {\n        mounted() {\n            let sakura_point_vsh: string = `\n    uniform mat4 uProjection;\n    uniform mat4 uModelview;\n    uniform vec3 uResolution;\n    uniform vec3 uOffset;\n    uniform vec3 uDOF;  //x:focus distance, y:focus radius, z:max radius\n    uniform vec3 uFade; //x:start distance, y:half distance, z:near fade start\n\n    attribute vec3 aPosition;\n    attribute vec3 aEuler;\n    attribute vec2 aMisc; //x:size, y:fade\n\n    varying vec3 pposition;\n    varying float psize;\n    varying float palpha;\n    varying float pdist;\n\n    //varying mat3 rotMat;\n    varying vec3 normX;\n    varying vec3 normY;\n    varying vec3 normZ;\n    varying vec3 normal;\n\n    varying float diffuse;\n    varying float specular;\n    varying float rstop;\n    varying float distancefade;\n\n    void main(void) {\n        // Projection is based on vertical angle\n        vec4 pos = uModelview * vec4(aPosition + uOffset, 1.0);\n        gl_Position = uProjection * pos;\n        gl_PointSize = aMisc.x * uProjection[1][1] / -pos.z * uResolution.y * 0.5;\n\n        pposition = pos.xyz;\n        psize = aMisc.x;\n        pdist = length(pos.xyz);\n        palpha = smoothstep(0.0, 1.0, (pdist - 0.1) / uFade.z);\n\n        vec3 elrsn = sin(aEuler);\n        vec3 elrcs = cos(aEuler);\n        mat3 rotx = mat3(\n            1.0, 0.0, 0.0,\n            0.0, elrcs.x, elrsn.x,\n            0.0, -elrsn.x, elrcs.x\n        );\n        mat3 roty = mat3(\n            elrcs.y, 0.0, -elrsn.y,\n            0.0, 1.0, 0.0,\n            elrsn.y, 0.0, elrcs.y\n        );\n        mat3 rotz = mat3(\n            elrcs.z, elrsn.z, 0.0,\n            -elrsn.z, elrcs.z, 0.0,\n            0.0, 0.0, 1.0\n        );\n        mat3 rotmat = rotx * roty * rotz;\n        normal = rotmat[2];\n\n        mat3 trrotm = mat3(\n            rotmat[0][0], rotmat[1][0], rotmat[2][0],\n            rotmat[0][1], rotmat[1][1], rotmat[2][1],\n            rotmat[0][2], rotmat[1][2], rotmat[2][2]\n        );\n        normX = trrotm[0];\n        normY = trrotm[1];\n        normZ = trrotm[2];\n\n        const vec3 lit = vec3(0.6917144638660746, 0.6917144638660746, -0.20751433915982237);\n\n        float tmpdfs = dot(lit, normal);\n        if(tmpdfs < 0.0) {\n            normal = -normal;\n            tmpdfs = dot(lit, normal);\n        }\n        diffuse = 0.4 + tmpdfs;\n\n        vec3 eyev = normalize(-pos.xyz);\n        if(dot(eyev, normal) > 0.0) {\n            vec3 hv = normalize(eyev + lit);\n            specular = pow(max(dot(hv, normal), 0.0), 20.0);\n        }\n        else {\n            specular = 0.0;\n        }\n\n        rstop = clamp((abs(pdist - uDOF.x) - uDOF.y) / uDOF.z, 0.0, 1.0);\n        rstop = pow(rstop, 0.5);\n        //-0.69315 = ln(0.5)\n        distancefade = min(1.0, exp((uFade.x - pdist) * 0.69315 / uFade.y));\n    }`;\n            let sakura_point_fsh: string = `\n    #ifdef GL_ES\n    //precision mediump float;\n    precision highp float;\n    #endif\n\n    uniform vec3 uDOF;  //x:focus distance, y:focus radius, z:max radius\n    uniform vec3 uFade; //x:start distance, y:half distance, z:near fade start\n\n    const vec3 fadeCol = vec3(0.08, 0.03, 0.06);\n\n    varying vec3 pposition;\n    varying float psize;\n    varying float palpha;\n    varying float pdist;\n\n    //varying mat3 rotMat;\n    varying vec3 normX;\n    varying vec3 normY;\n    varying vec3 normZ;\n    varying vec3 normal;\n\n    varying float diffuse;\n    varying float specular;\n    varying float rstop;\n    varying float distancefade;\n\n    float ellipse(vec2 p, vec2 o, vec2 r) {\n        vec2 lp = (p - o) / r;\n        return length(lp) - 1.0;\n    }\n\n    void main(void) {\n        vec3 p = vec3(gl_PointCoord - vec2(0.5, 0.5), 0.0) * 2.0;\n        vec3 d = vec3(0.0, 0.0, -1.0);\n        float nd = normZ.z; //dot(-normZ, d);\n        if(abs(nd) < 0.0001) discard;\n\n        float np = dot(normZ, p);\n        vec3 tp = p + d * np / nd;\n        vec2 coord = vec2(dot(normX, tp), dot(normY, tp));\n\n        //angle = 15 degree\n        const float flwrsn = 0.258819045102521;\n        const float flwrcs = 0.965925826289068;\n        mat2 flwrm = mat2(flwrcs, -flwrsn, flwrsn, flwrcs);\n        vec2 flwrp = vec2(abs(coord.x), coord.y) * flwrm;\n\n        float r;\n        if(flwrp.x < 0.0) {\n            r = ellipse(flwrp, vec2(0.065, 0.024) * 0.5, vec2(0.36, 0.96) * 0.5);\n        }\n        else {\n            r = ellipse(flwrp, vec2(0.065, 0.024) * 0.5, vec2(0.58, 0.96) * 0.5);\n        }\n\n        if(r > rstop) discard;\n\n        vec3 col = mix(vec3(1.0, 0.8, 0.75), vec3(1.0, 0.9, 0.87), r);\n        float grady = mix(0.0, 1.0, pow(coord.y * 0.5 + 0.5, 0.35));\n        col *= vec3(1.0, grady, grady);\n        col *= mix(0.8, 1.0, pow(abs(coord.x), 0.3));\n        col = col * diffuse + specular;\n\n        col = mix(fadeCol, col, distancefade);\n\n        float alpha = (rstop > 0.001)? (0.5 - r / (rstop * 2.0)) : 1.0;\n        alpha = smoothstep(0.0, 1.0, alpha) * palpha;\n\n        gl_FragColor = vec4(col * 0.5, alpha);\n    }`;\n            let fx_common_vsh: string = `\n    uniform vec3 uResolution;\n    attribute vec2 aPosition;\n\n    varying vec2 texCoord;\n    varying vec2 screenCoord;\n\n    void main(void) {\n        gl_Position = vec4(aPosition, 0.0, 1.0);\n        texCoord = aPosition.xy * 0.5 + vec2(0.5, 0.5);\n        screenCoord = aPosition.xy * vec2(uResolution.z, 1.0);\n    }`;\n            let bg_fsh: string = `\n    #ifdef GL_ES\n    //precision mediump float;\n    precision highp float;\n    #endif\n\n    uniform vec2 uTimes;\n\n    varying vec2 texCoord;\n    varying vec2 screenCoord;\n\n    void main(void) {\n        vec3 col;\n        float c;\n        vec2 tmpv = texCoord * vec2(0.8, 1.0) - vec2(0.95, 1.0);\n        c = exp(-pow(length(tmpv) * 1.8, 2.0));\n        col = mix(vec3(0.02, 0.0, 0.03), vec3(0.96, 0.98, 1.0) * 1.5, c);\n        gl_FragColor = vec4(col * 0.5, 1.0);\n    }`;\n            let fx_brightbuf_fsh: string = `\n    #ifdef GL_ES\n    //precision mediump float;\n    precision highp float;\n    #endif\n    uniform sampler2D uSrc;\n    uniform vec2 uDelta;\n\n    varying vec2 texCoord;\n    varying vec2 screenCoord;\n\n    void main(void) {\n        vec4 col = texture2D(uSrc, texCoord);\n        gl_FragColor = vec4(col.rgb * 2.0 - vec3(0.5), 1.0);\n    }`;\n            let fx_dirblur_r4_fsh: string = `\n    #ifdef GL_ES\n    //precision mediump float;\n    precision highp float;\n    #endif\n    uniform sampler2D uSrc;\n    uniform vec2 uDelta;\n    uniform vec4 uBlurDir; //dir(x, y), stride(z, w)\n\n    varying vec2 texCoord;\n    varying vec2 screenCoord;\n\n    void main(void) {\n        vec4 col = texture2D(uSrc, texCoord);\n        col = col + texture2D(uSrc, texCoord + uBlurDir.xy * uDelta);\n        col = col + texture2D(uSrc, texCoord - uBlurDir.xy * uDelta);\n        col = col + texture2D(uSrc, texCoord + (uBlurDir.xy + uBlurDir.zw) * uDelta);\n        col = col + texture2D(uSrc, texCoord - (uBlurDir.xy + uBlurDir.zw) * uDelta);\n        gl_FragColor = col / 5.0;\n    }`;\n            let pp_final_vsh: string = `\n    uniform vec3 uResolution;\n    attribute vec2 aPosition;\n    varying vec2 texCoord;\n    varying vec2 screenCoord;\n    void main(void) {\n        gl_Position = vec4(aPosition, 0.0, 1.0);\n        texCoord = aPosition.xy * 0.5 + vec2(0.5, 0.5);\n        screenCoord = aPosition.xy * vec2(uResolution.z, 1.0);\n    }`;\n            let pp_final_fsh: string = `\n    #ifdef GL_ES\n    //precision mediump float;\n    precision highp float;\n    #endif\n    uniform sampler2D uSrc;\n    uniform sampler2D uBloom;\n    uniform vec2 uDelta;\n    varying vec2 texCoord;\n    varying vec2 screenCoord;\n    void main(void) {\n        vec4 srccol = texture2D(uSrc, texCoord) * 2.0;\n        vec4 bloomcol = texture2D(uBloom, texCoord);\n        vec4 col;\n        col = srccol + bloomcol * (vec4(1.0) + srccol);\n        col *= smoothstep(1.0, 0.0, pow(length((texCoord - vec2(0.5)) * 2.0), 1.2) * 0.5);\n        col = pow(col, vec4(0.45454545454545)); //(1.0 / 2.2)\n\n        gl_FragColor = vec4(col.rgb, 1.0);\n        gl_FragColor.a = 1.0;\n    }`;\n\n            // Utilities\n            var Vector3: any = {};\n            var Matrix44: any = {};\n            Vector3.create = function(x: any, y: any, z: any) {\n                return {x: x, y: y, z: z};\n            };\n            Vector3.dot = function(v0: any, v1: any) {\n                return v0.x * v1.x + v0.y * v1.y + v0.z * v1.z;\n            };\n            Vector3.cross = function(v: any, v0: any, v1: any) {\n                v.x = v0.y * v1.z - v0.z * v1.y;\n                v.y = v0.z * v1.x - v0.x * v1.z;\n                v.z = v0.x * v1.y - v0.y * v1.x;\n            };\n            Vector3.normalize = function(v: any) {\n                var l: any = v.x * v.x + v.y * v.y + v.z * v.z;\n                if (l > 0.00001) {\n                    l = 1.0 / Math.sqrt(l);\n                    v.x *= l;\n                    v.y *= l;\n                    v.z *= l;\n                }\n            };\n            Vector3.arrayForm = function(v: any) {\n                if (v.array) {\n                    v.array[0] = v.x;\n                    v.array[1] = v.y;\n                    v.array[2] = v.z;\n                } else {\n                    v.array = new Float32Array([v.x, v.y, v.z]);\n                }\n                return v.array;\n            };\n            Matrix44.createIdentity = function() {\n                return new Float32Array([\n                    1.0,\n                    0.0,\n                    0.0,\n                    0.0,\n                    0.0,\n                    1.0,\n                    0.0,\n                    0.0,\n                    0.0,\n                    0.0,\n                    1.0,\n                    0.0,\n                    0.0,\n                    0.0,\n                    0.0,\n                    1.0\n                ]);\n            };\n            Matrix44.loadProjection = function(\n                m: any,\n                aspect: any,\n                vdeg: any,\n                near: any,\n                far: any\n            ) {\n                let h = near * Math.tan(((vdeg * Math.PI) / 180.0) * 0.5) * 2.0;\n                let w = h * aspect;\n\n                m[0] = (2.0 * near) / w;\n                m[1] = 0.0;\n                m[2] = 0.0;\n                m[3] = 0.0;\n\n                m[4] = 0.0;\n                m[5] = (2.0 * near) / h;\n                m[6] = 0.0;\n                m[7] = 0.0;\n\n                m[8] = 0.0;\n                m[9] = 0.0;\n                m[10] = -(far + near) / (far - near);\n                m[11] = -1.0;\n\n                m[12] = 0.0;\n                m[13] = 0.0;\n                m[14] = (-2.0 * far * near) / (far - near);\n                m[15] = 0.0;\n            };\n            Matrix44.loadLookAt = function(m: any, vpos: any, vlook: any, vup: any) {\n                let frontv = Vector3.create(\n                    vpos.x - vlook.x,\n                    vpos.y - vlook.y,\n                    vpos.z - vlook.z\n                );\n                Vector3.normalize(frontv);\n                let sidev = Vector3.create(1.0, 0.0, 0.0);\n                Vector3.cross(sidev, vup, frontv);\n                Vector3.normalize(sidev);\n                let topv = Vector3.create(1.0, 0.0, 0.0);\n                Vector3.cross(topv, frontv, sidev);\n                Vector3.normalize(topv);\n\n                m[0] = sidev.x;\n                m[1] = topv.x;\n                m[2] = frontv.x;\n                m[3] = 0.0;\n\n                m[4] = sidev.y;\n                m[5] = topv.y;\n                m[6] = frontv.y;\n                m[7] = 0.0;\n\n                m[8] = sidev.z;\n                m[9] = topv.z;\n                m[10] = frontv.z;\n                m[11] = 0.0;\n\n                m[12] = -(vpos.x * m[0] + vpos.y * m[4] + vpos.z * m[8]);\n                m[13] = -(vpos.x * m[1] + vpos.y * m[5] + vpos.z * m[9]);\n                m[14] = -(vpos.x * m[2] + vpos.y * m[6] + vpos.z * m[10]);\n                m[15] = 1.0;\n            };\n\n            //\n            var timeInfo: any = {\n                start: 0,\n                prev: 0, // Date\n                delta: 0,\n                elapsed: 0 // Number(sec)\n            };\n\n            //\n            var gl: any;\n            var renderSpec: any = {\n                width: 0,\n                height: 0,\n                aspect: 1,\n                array: new Float32Array(3),\n                halfWidth: 0,\n                halfHeight: 0,\n                halfArray: new Float32Array(3)\n                // and some render targets. see setViewport()\n            };\n            renderSpec.setSize = function(w: any, h: any) {\n                renderSpec.width = w;\n                renderSpec.height = h;\n                renderSpec.aspect = renderSpec.width / renderSpec.height;\n                renderSpec.array[0] = renderSpec.width;\n                renderSpec.array[1] = renderSpec.height;\n                renderSpec.array[2] = renderSpec.aspect;\n\n                renderSpec.halfWidth = Math.floor(w / 2);\n                renderSpec.halfHeight = Math.floor(h / 2);\n                renderSpec.halfArray[0] = renderSpec.halfWidth;\n                renderSpec.halfArray[1] = renderSpec.halfHeight;\n                renderSpec.halfArray[2] = renderSpec.halfWidth / renderSpec.halfHeight;\n            };\n\n            function deleteRenderTarget(rt: any) {\n                gl.deleteFramebuffer(rt.frameBuffer);\n                gl.deleteRenderbuffer(rt.renderBuffer);\n                gl.deleteTexture(rt.texture);\n            }\n\n            function createRenderTarget(w: any, h: any) {\n                var ret: any = {\n                    width: w,\n                    height: h,\n                    sizeArray: new Float32Array([w, h, w / h]),\n                    dtxArray: new Float32Array([1.0 / w, 1.0 / h])\n                };\n                ret.frameBuffer = gl.createFramebuffer();\n                ret.renderBuffer = gl.createRenderbuffer();\n                ret.texture = gl.createTexture();\n\n                gl.bindTexture(gl.TEXTURE_2D, ret.texture);\n                gl.texImage2D(\n                    gl.TEXTURE_2D,\n                    0,\n                    gl.RGBA,\n                    w,\n                    h,\n                    0,\n                    gl.RGBA,\n                    gl.UNSIGNED_BYTE,\n                    null\n                );\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n\n                gl.bindFramebuffer(gl.FRAMEBUFFER, ret.frameBuffer);\n                gl.framebufferTexture2D(\n                    gl.FRAMEBUFFER,\n                    gl.COLOR_ATTACHMENT0,\n                    gl.TEXTURE_2D,\n                    ret.texture,\n                    0\n                );\n\n                gl.bindRenderbuffer(gl.RENDERBUFFER, ret.renderBuffer);\n                gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, w, h);\n                gl.framebufferRenderbuffer(\n                    gl.FRAMEBUFFER,\n                    gl.DEPTH_ATTACHMENT,\n                    gl.RENDERBUFFER,\n                    ret.renderBuffer\n                );\n\n                gl.bindTexture(gl.TEXTURE_2D, null);\n                gl.bindRenderbuffer(gl.RENDERBUFFER, null);\n                gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n                return ret;\n            }\n\n            function compileShader(shtype: any, shsrc: any) {\n                var retsh: any = gl.createShader(shtype);\n\n                gl.shaderSource(retsh, shsrc);\n                gl.compileShader(retsh);\n\n                if (!gl.getShaderParameter(retsh, gl.COMPILE_STATUS)) {\n                    var errlog: any = gl.getShaderInfoLog(retsh);\n                    gl.deleteShader(retsh);\n                    console.error(errlog);\n                    return null;\n                }\n                return retsh;\n            }\n\n            function createShader(\n                vtxsrc: any,\n                frgsrc: any,\n                uniformlist: any,\n                attrlist: any\n            ) {\n                var vsh: any = compileShader(gl.VERTEX_SHADER, vtxsrc);\n                var fsh: any = compileShader(gl.FRAGMENT_SHADER, frgsrc);\n\n                if (vsh == null || fsh == null) {\n                    return null;\n                }\n\n                var prog: any = gl.createProgram();\n                gl.attachShader(prog, vsh);\n                gl.attachShader(prog, fsh);\n\n                gl.deleteShader(vsh);\n                gl.deleteShader(fsh);\n\n                gl.linkProgram(prog);\n                if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {\n                    var errlog: any = gl.getProgramInfoLog(prog);\n                    console.error(errlog);\n                    return null;\n                }\n\n                if (uniformlist) {\n                    prog.uniforms = {};\n                    for (var i = 0; i < uniformlist.length; i++) {\n                        prog.uniforms[uniformlist[i]] = gl.getUniformLocation(\n                            prog,\n                            uniformlist[i]\n                        );\n                    }\n                }\n\n                if (attrlist) {\n                    prog.attributes = {};\n                    for (let i = 0; i < attrlist.length; i++) {\n                        let attr = attrlist[i];\n                        prog.attributes[attr] = gl.getAttribLocation(prog, attr);\n                    }\n                }\n\n                return prog;\n            }\n\n            function useShader(prog: any) {\n                gl.useProgram(prog);\n                for (let attr in prog.attributes) {\n                    gl.enableVertexAttribArray(prog.attributes[attr]);\n                }\n            }\n\n            function unuseShader(prog: any) {\n                for (let attr in prog.attributes) {\n                    gl.disableVertexAttribArray(prog.attributes[attr]);\n                }\n                gl.useProgram(null);\n            }\n\n            /////\n            var projection: any = {\n                angle: 60,\n                nearfar: new Float32Array([0.1, 100.0]),\n                matrix: Matrix44.createIdentity()\n            };\n            var camera: any = {\n                position: Vector3.create(0, 0, 100),\n                lookat: Vector3.create(0, 0, 0),\n                up: Vector3.create(0, 1, 0),\n                dof: Vector3.create(10.0, 4.0, 8.0),\n                matrix: Matrix44.createIdentity()\n            };\n\n            var pointFlower: any = {};\n            // var meshFlower = {};\n            var sceneStandBy: any = false;\n\n            var BlossomParticle: any = function() {\n                this.velocity = new Array(3);\n                this.rotation = new Array(3);\n                this.position = new Array(3);\n                this.euler = new Array(3);\n                this.size = 1.0;\n                this.alpha = 1.0;\n                this.zkey = 0.0;\n            };\n\n            BlossomParticle.prototype.setVelocity = function(\n                vx: any,\n                vy: any,\n                vz: any\n            ) {\n                this.velocity[0] = vx;\n                this.velocity[1] = vy;\n                this.velocity[2] = vz;\n            };\n\n            BlossomParticle.prototype.setRotation = function(\n                rx: any,\n                ry: any,\n                rz: any\n            ) {\n                this.rotation[0] = rx;\n                this.rotation[1] = ry;\n                this.rotation[2] = rz;\n            };\n\n            BlossomParticle.prototype.setPosition = function(\n                nx: any,\n                ny: any,\n                nz: any\n            ) {\n                this.position[0] = nx;\n                this.position[1] = ny;\n                this.position[2] = nz;\n            };\n\n            BlossomParticle.prototype.setEulerAngles = function(\n                rx: any,\n                ry: any,\n                rz: any\n            ) {\n                this.euler[0] = rx;\n                this.euler[1] = ry;\n                this.euler[2] = rz;\n            };\n\n            BlossomParticle.prototype.setSize = function(s: any) {\n                this.size = s;\n            };\n\n            BlossomParticle.prototype.update = function(dt: any, et: any) {\n                this.position[0] += this.velocity[0] * dt;\n                this.position[1] += this.velocity[1] * dt;\n                this.position[2] += this.velocity[2] * dt;\n\n                this.euler[0] += this.rotation[0] * dt;\n                this.euler[1] += this.rotation[1] * dt;\n                this.euler[2] += this.rotation[2] * dt;\n            };\n\n            function createPointFlowers() {\n                // get point sizes\n                var prm: any = gl.getParameter(gl.ALIASED_POINT_SIZE_RANGE);\n                renderSpec.pointSize = {min: prm[0], max: prm[1]};\n\n                var vtxsrc: any = sakura_point_vsh;\n                var frgsrc: any = sakura_point_fsh;\n\n                pointFlower.program = createShader(\n                    vtxsrc,\n                    frgsrc,\n                    [\n                        \"uProjection\",\n                        \"uModelview\",\n                        \"uResolution\",\n                        \"uOffset\",\n                        \"uDOF\",\n                        \"uFade\"\n                    ],\n                    [\"aPosition\", \"aEuler\", \"aMisc\"]\n                );\n\n                useShader(pointFlower.program);\n                pointFlower.offset = new Float32Array([0.0, 0.0, 0.0]);\n                pointFlower.fader = Vector3.create(0.0, 10.0, 0.0);\n\n                // paramerters: velocity[3], rotate[3]\n                pointFlower.numFlowers = 1600;\n                pointFlower.particles = new Array(pointFlower.numFlowers);\n                // vertex attributes {position[3], euler_xyz[3], size[1]}\n                pointFlower.dataArray = new Float32Array(\n                    pointFlower.numFlowers * (3 + 3 + 2)\n                );\n                pointFlower.positionArrayOffset = 0;\n                pointFlower.eulerArrayOffset = pointFlower.numFlowers * 3;\n                pointFlower.miscArrayOffset = pointFlower.numFlowers * 6;\n\n                pointFlower.buffer = gl.createBuffer();\n                gl.bindBuffer(gl.ARRAY_BUFFER, pointFlower.buffer);\n                gl.bufferData(gl.ARRAY_BUFFER, pointFlower.dataArray, gl.DYNAMIC_DRAW);\n                gl.bindBuffer(gl.ARRAY_BUFFER, null);\n\n                unuseShader(pointFlower.program);\n\n                for (let i = 0; i < pointFlower.numFlowers; i++) {\n                    pointFlower.particles[i] = new BlossomParticle();\n                }\n            }\n\n            function initPointFlowers() {\n                //area\n                pointFlower.area = Vector3.create(20.0, 20.0, 20.0);\n                pointFlower.area.x = pointFlower.area.y * renderSpec.aspect;\n\n                pointFlower.fader.x = 10.0; //env fade start\n                pointFlower.fader.y = pointFlower.area.z; //env fade half\n                pointFlower.fader.z = 0.1; //near fade start\n\n                //particles\n                var PI2: any = Math.PI * 2.0;\n                var tmpv3: any = Vector3.create(0, 0, 0);\n                var tmpv: any = 0;\n                var symmetryrand: any = function() {\n                    return Math.random() * 2.0 - 1.0;\n                };\n                for (let i = 0; i < pointFlower.numFlowers; i++) {\n                    let tmpprtcl = pointFlower.particles[i];\n\n                    //velocity\n                    tmpv3.x = symmetryrand() * 0.3 + 0.8;\n                    tmpv3.y = symmetryrand() * 0.2 - 1.0;\n                    tmpv3.z = symmetryrand() * 0.3 + 0.5;\n                    Vector3.normalize(tmpv3);\n                    tmpv = 2.0 + Math.random() * 1.0;\n                    tmpprtcl.setVelocity(tmpv3.x * tmpv, tmpv3.y * tmpv, tmpv3.z * tmpv);\n\n                    //rotation\n                    tmpprtcl.setRotation(\n                        symmetryrand() * PI2 * 0.5,\n                        symmetryrand() * PI2 * 0.5,\n                        symmetryrand() * PI2 * 0.5\n                    );\n\n                    //position\n                    tmpprtcl.setPosition(\n                        symmetryrand() * pointFlower.area.x,\n                        symmetryrand() * pointFlower.area.y,\n                        symmetryrand() * pointFlower.area.z\n                    );\n\n                    //euler\n                    tmpprtcl.setEulerAngles(\n                        Math.random() * Math.PI * 2.0,\n                        Math.random() * Math.PI * 2.0,\n                        Math.random() * Math.PI * 2.0\n                    );\n\n                    //size\n                    tmpprtcl.setSize(0.9 + Math.random() * 0.1);\n                }\n            }\n\n            function renderPointFlowers() {\n                //update\n                var PI2: any = Math.PI * 2.0;\n                // var limit = [pointFlower.area.x, pointFlower.area.y, pointFlower.area.z];\n                var repeatPos: any = function(prt: any, cmp: any, limit: any) {\n                    if (Math.abs(prt.position[cmp]) - prt.size * 0.5 > limit) {\n                        //out of area\n                        if (prt.position[cmp] > 0) {\n                            prt.position[cmp] -= limit * 2.0;\n                        } else {\n                            prt.position[cmp] += limit * 2.0;\n                        }\n                    }\n                };\n                var repeatEuler: any = function(prt: any, cmp: any) {\n                    prt.euler[cmp] = prt.euler[cmp] % PI2;\n                    if (prt.euler[cmp] < 0.0) {\n                        prt.euler[cmp] += PI2;\n                    }\n                };\n\n                for (let i = 0; i < pointFlower.numFlowers; i++) {\n                    let prtcl = pointFlower.particles[i];\n                    prtcl.update(timeInfo.delta, timeInfo.elapsed);\n                    repeatPos(prtcl, 0, pointFlower.area.x);\n                    repeatPos(prtcl, 1, pointFlower.area.y);\n                    repeatPos(prtcl, 2, pointFlower.area.z);\n                    repeatEuler(prtcl, 0);\n                    repeatEuler(prtcl, 1);\n                    repeatEuler(prtcl, 2);\n\n                    prtcl.alpha = 1.0; //(pointFlower.area.z - prtcl.position[2]) * 0.5;\n\n                    prtcl.zkey =\n                        camera.matrix[2] * prtcl.position[0] +\n                        camera.matrix[6] * prtcl.position[1] +\n                        camera.matrix[10] * prtcl.position[2] +\n                        camera.matrix[14];\n                }\n\n                // sort\n                pointFlower.particles.sort(function(p0: any, p1: any) {\n                    return p0.zkey - p1.zkey;\n                });\n\n                // update data\n                var ipos: any = pointFlower.positionArrayOffset;\n                var ieuler: any = pointFlower.eulerArrayOffset;\n                var imisc: any = pointFlower.miscArrayOffset;\n                for (let i = 0; i < pointFlower.numFlowers; i++) {\n                    let prtcl = pointFlower.particles[i];\n                    pointFlower.dataArray[ipos] = prtcl.position[0];\n                    pointFlower.dataArray[ipos + 1] = prtcl.position[1];\n                    pointFlower.dataArray[ipos + 2] = prtcl.position[2];\n                    ipos += 3;\n                    pointFlower.dataArray[ieuler] = prtcl.euler[0];\n                    pointFlower.dataArray[ieuler + 1] = prtcl.euler[1];\n                    pointFlower.dataArray[ieuler + 2] = prtcl.euler[2];\n                    ieuler += 3;\n                    pointFlower.dataArray[imisc] = prtcl.size;\n                    pointFlower.dataArray[imisc + 1] = prtcl.alpha;\n                    imisc += 2;\n                }\n\n                //draw\n                gl.enable(gl.BLEND);\n                //gl.disable(gl.DEPTH_TEST);\n                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n\n                var prog: any = pointFlower.program;\n                useShader(prog);\n\n                gl.uniformMatrix4fv(prog.uniforms.uProjection, false, projection.matrix);\n                gl.uniformMatrix4fv(prog.uniforms.uModelview, false, camera.matrix);\n                gl.uniform3fv(prog.uniforms.uResolution, renderSpec.array);\n                gl.uniform3fv(prog.uniforms.uDOF, Vector3.arrayForm(camera.dof));\n                gl.uniform3fv(prog.uniforms.uFade, Vector3.arrayForm(pointFlower.fader));\n\n                gl.bindBuffer(gl.ARRAY_BUFFER, pointFlower.buffer);\n                gl.bufferData(gl.ARRAY_BUFFER, pointFlower.dataArray, gl.DYNAMIC_DRAW);\n\n                gl.vertexAttribPointer(\n                    prog.attributes.aPosition,\n                    3,\n                    gl.FLOAT,\n                    false,\n                    0,\n                    pointFlower.positionArrayOffset * Float32Array.BYTES_PER_ELEMENT\n                );\n                gl.vertexAttribPointer(\n                    prog.attributes.aEuler,\n                    3,\n                    gl.FLOAT,\n                    false,\n                    0,\n                    pointFlower.eulerArrayOffset * Float32Array.BYTES_PER_ELEMENT\n                );\n                gl.vertexAttribPointer(\n                    prog.attributes.aMisc,\n                    2,\n                    gl.FLOAT,\n                    false,\n                    0,\n                    pointFlower.miscArrayOffset * Float32Array.BYTES_PER_ELEMENT\n                );\n\n                // doubler\n                for (let i = 1; i < 2; i++) {\n                    let zpos = i * -2.0;\n                    pointFlower.offset[0] = pointFlower.area.x * -1.0;\n                    pointFlower.offset[1] = pointFlower.area.y * -1.0;\n                    pointFlower.offset[2] = pointFlower.area.z * zpos;\n                    gl.uniform3fv(prog.uniforms.uOffset, pointFlower.offset);\n                    gl.drawArrays(gl.POINT, 0, pointFlower.numFlowers);\n\n                    pointFlower.offset[0] = pointFlower.area.x * -1.0;\n                    pointFlower.offset[1] = pointFlower.area.y * 1.0;\n                    pointFlower.offset[2] = pointFlower.area.z * zpos;\n                    gl.uniform3fv(prog.uniforms.uOffset, pointFlower.offset);\n                    gl.drawArrays(gl.POINT, 0, pointFlower.numFlowers);\n\n                    pointFlower.offset[0] = pointFlower.area.x * 1.0;\n                    pointFlower.offset[1] = pointFlower.area.y * -1.0;\n                    pointFlower.offset[2] = pointFlower.area.z * zpos;\n                    gl.uniform3fv(prog.uniforms.uOffset, pointFlower.offset);\n                    gl.drawArrays(gl.POINT, 0, pointFlower.numFlowers);\n\n                    pointFlower.offset[0] = pointFlower.area.x * 1.0;\n                    pointFlower.offset[1] = pointFlower.area.y * 1.0;\n                    pointFlower.offset[2] = pointFlower.area.z * zpos;\n                    gl.uniform3fv(prog.uniforms.uOffset, pointFlower.offset);\n                    gl.drawArrays(gl.POINT, 0, pointFlower.numFlowers);\n                }\n\n                //main\n                pointFlower.offset[0] = 0.0;\n                pointFlower.offset[1] = 0.0;\n                pointFlower.offset[2] = 0.0;\n                gl.uniform3fv(prog.uniforms.uOffset, pointFlower.offset);\n                gl.drawArrays(gl.POINT, 0, pointFlower.numFlowers);\n\n                gl.bindBuffer(gl.ARRAY_BUFFER, null);\n                unuseShader(prog);\n\n                gl.enable(gl.DEPTH_TEST);\n                gl.disable(gl.BLEND);\n            }\n\n            // effects\n            //common util\n            function createEffectProgram(\n                vtxsrc: any,\n                frgsrc: any,\n                exunifs: any,\n                exattrs: any\n            ) {\n                var ret: any = {};\n                var unifs: any = [\"uResolution\", \"uSrc\", \"uDelta\"];\n                if (exunifs) {\n                    unifs = unifs.concat(exunifs);\n                }\n                var attrs: any = [\"aPosition\"];\n                if (exattrs) {\n                    attrs = attrs.concat(exattrs);\n                }\n\n                ret.program = createShader(vtxsrc, frgsrc, unifs, attrs);\n                useShader(ret.program);\n\n                ret.dataArray = new Float32Array([\n                    -1.0,\n                    -1.0,\n                    1.0,\n                    -1.0,\n                    -1.0,\n                    1.0,\n                    1.0,\n                    1.0\n                ]);\n                ret.buffer = gl.createBuffer();\n                gl.bindBuffer(gl.ARRAY_BUFFER, ret.buffer);\n                gl.bufferData(gl.ARRAY_BUFFER, ret.dataArray, gl.STATIC_DRAW);\n\n                gl.bindBuffer(gl.ARRAY_BUFFER, null);\n                unuseShader(ret.program);\n\n                return ret;\n            }\n\n            function useEffect(fxobj: any, srctex: any) {\n                var prog: any = fxobj.program;\n                useShader(prog);\n                gl.uniform3fv(prog.uniforms.uResolution, renderSpec.array);\n\n                if (srctex != null) {\n                    gl.uniform2fv(prog.uniforms.uDelta, srctex.dtxArray);\n                    gl.uniform1i(prog.uniforms.uSrc, 0);\n\n                    gl.activeTexture(gl.TEXTURE0);\n                    gl.bindTexture(gl.TEXTURE_2D, srctex.texture);\n                }\n            }\n\n            function drawEffect(fxobj: any) {\n                gl.bindBuffer(gl.ARRAY_BUFFER, fxobj.buffer);\n                gl.vertexAttribPointer(\n                    fxobj.program.attributes.aPosition,\n                    2,\n                    gl.FLOAT,\n                    false,\n                    0,\n                    0\n                );\n                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n            }\n\n            function unuseEffect(fxobj: any) {\n                unuseShader(fxobj.program);\n            }\n\n            var effectLib: any = {};\n\n            function createEffectLib() {\n                var vtxsrc: any, frgsrc: any;\n                //common\n                var cmnvtxsrc: any = fx_common_vsh;\n\n                //background\n                frgsrc = bg_fsh;\n                effectLib.sceneBg = createEffectProgram(\n                    cmnvtxsrc,\n                    frgsrc,\n                    [\"uTimes\"],\n                    null\n                );\n\n                // make brightpixels buffer\n                frgsrc = fx_brightbuf_fsh;\n                effectLib.mkBrightBuf = createEffectProgram(\n                    cmnvtxsrc,\n                    frgsrc,\n                    null,\n                    null\n                );\n\n                // direction blur\n                frgsrc = fx_dirblur_r4_fsh;\n                effectLib.dirBlur = createEffectProgram(\n                    cmnvtxsrc,\n                    frgsrc,\n                    [\"uBlurDir\"],\n                    null\n                );\n\n                //final composite\n                vtxsrc = pp_final_vsh;\n                frgsrc = pp_final_fsh;\n                // console.log('frgsrc :',frgsrc )\n                effectLib.finalComp = createEffectProgram(\n                    vtxsrc,\n                    frgsrc,\n                    [\"uBloom\"],\n                    null\n                );\n            }\n\n            // background\n            function createBackground() {\n                //console.log(\"create background\");\n            }\n\n            function initBackground() {\n                //console.log(\"init background\");\n            }\n\n            function renderBackground() {\n                gl.disable(gl.DEPTH_TEST);\n\n                useEffect(effectLib.sceneBg, null);\n                gl.uniform2f(\n                    effectLib.sceneBg.program.uniforms.uTimes,\n                    timeInfo.elapsed,\n                    timeInfo.delta\n                );\n                drawEffect(effectLib.sceneBg);\n                unuseEffect(effectLib.sceneBg);\n\n                gl.enable(gl.DEPTH_TEST);\n            }\n\n            // post process\n            // var postProcess = {};\n            function createPostProcess() {\n                //console.log(\"create post process\");\n            }\n\n            function initPostProcess() {\n                //console.log(\"init post process\");\n            }\n\n            function renderPostProcess() {\n                // gl.enable(gl.TEXTURE_2D);\n                gl.disable(gl.DEPTH_TEST);\n                var bindRT: any = function(rt: any, isclear: any) {\n                    gl.bindFramebuffer(gl.FRAMEBUFFER, rt.frameBuffer);\n                    gl.viewport(0, 0, rt.width, rt.height);\n                    if (isclear) {\n                        gl.clearColor(0, 0, 0, 0);\n                        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n                    }\n                };\n\n                //make bright buff\n                bindRT(renderSpec.wHalfRT0, true);\n                useEffect(effectLib.mkBrightBuf, renderSpec.mainRT);\n                drawEffect(effectLib.mkBrightBuf);\n                unuseEffect(effectLib.mkBrightBuf);\n\n                // make bloom\n                for (let i = 0; i < 2; i++) {\n                    let p = 1.5 + 1 * i;\n                    let s = 2.0 + 1 * i;\n                    bindRT(renderSpec.wHalfRT1, true);\n                    useEffect(effectLib.dirBlur, renderSpec.wHalfRT0);\n                    gl.uniform4f(\n                        effectLib.dirBlur.program.uniforms.uBlurDir,\n                        p,\n                        0.0,\n                        s,\n                        0.0\n                    );\n                    drawEffect(effectLib.dirBlur);\n                    unuseEffect(effectLib.dirBlur);\n\n                    bindRT(renderSpec.wHalfRT0, true);\n                    useEffect(effectLib.dirBlur, renderSpec.wHalfRT1);\n                    gl.uniform4f(\n                        effectLib.dirBlur.program.uniforms.uBlurDir,\n                        0.0,\n                        p,\n                        0.0,\n                        s\n                    );\n                    drawEffect(effectLib.dirBlur);\n                    unuseEffect(effectLib.dirBlur);\n                }\n\n                //display\n                gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n                gl.viewport(0, 0, renderSpec.width, renderSpec.height);\n                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n\n                useEffect(effectLib.finalComp, renderSpec.mainRT);\n                gl.uniform1i(effectLib.finalComp.program.uniforms.uBloom, 1);\n                gl.activeTexture(gl.TEXTURE1);\n                gl.bindTexture(gl.TEXTURE_2D, renderSpec.wHalfRT0.texture);\n                drawEffect(effectLib.finalComp);\n                unuseEffect(effectLib.finalComp);\n\n                gl.enable(gl.DEPTH_TEST);\n            }\n\n            /////\n            // var SceneEnv = {};\n            function createScene() {\n                createEffectLib();\n                createBackground();\n                createPointFlowers();\n                createPostProcess();\n                sceneStandBy = true;\n            }\n\n            function initScene() {\n                initBackground();\n                initPointFlowers();\n                initPostProcess();\n\n                //camera.position.z = 17.320508;\n                camera.position.z = pointFlower.area.z + projection.nearfar[0];\n                projection.angle =\n                    ((Math.atan2(\n                        pointFlower.area.y,\n                        camera.position.z + pointFlower.area.z\n                        ) *\n                        180.0) /\n                        Math.PI) *\n                    2.0;\n                Matrix44.loadProjection(\n                    projection.matrix,\n                    renderSpec.aspect,\n                    projection.angle,\n                    projection.nearfar[0],\n                    projection.nearfar[1]\n                );\n            }\n\n            function renderScene() {\n                //draw\n                Matrix44.loadLookAt(\n                    camera.matrix,\n                    camera.position,\n                    camera.lookat,\n                    camera.up\n                );\n\n                gl.enable(gl.DEPTH_TEST);\n\n                //gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n                gl.bindFramebuffer(gl.FRAMEBUFFER, renderSpec.mainRT.frameBuffer);\n                gl.viewport(0, 0, renderSpec.mainRT.width, renderSpec.mainRT.height);\n                gl.clearColor(0.005, 0, 0.05, 0);\n                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n\n                renderBackground();\n                renderPointFlowers();\n                renderPostProcess();\n            }\n\n            /////\n            function onResize(e: any) {\n                makeCanvasFullScreen(document.getElementById(\"sakura\"));\n                setViewports();\n                if (sceneStandBy) {\n                    initScene();\n                }\n            }\n\n            function setViewports() {\n                renderSpec.setSize(gl.canvas.width, gl.canvas.height);\n\n                gl.clearColor(0.2, 0.2, 0.5, 1.0);\n                gl.viewport(0, 0, renderSpec.width, renderSpec.height);\n\n                var rtfunc: any = function(rtname: any, rtw: any, rth: any) {\n                    var rt: any = renderSpec[rtname];\n                    if (rt) {\n                        deleteRenderTarget(rt);\n                    }\n                    renderSpec[rtname] = createRenderTarget(rtw, rth);\n                };\n                rtfunc(\"mainRT\", renderSpec.width, renderSpec.height);\n                rtfunc(\"wFullRT0\", renderSpec.width, renderSpec.height);\n                rtfunc(\"wFullRT1\", renderSpec.width, renderSpec.height);\n                rtfunc(\"wHalfRT0\", renderSpec.halfWidth, renderSpec.halfHeight);\n                rtfunc(\"wHalfRT1\", renderSpec.halfWidth, renderSpec.halfHeight);\n            }\n\n            function render() {\n                renderScene();\n            }\n\n            var animating: boolean = true;\n\n            function animate() {\n                var curdate: any = new Date();\n                timeInfo.elapsed = (curdate - timeInfo.start) / 1000.0;\n                timeInfo.delta = (curdate - timeInfo.prev) / 1000.0;\n                timeInfo.prev = curdate;\n\n                if (animating) {\n                    requestAnimationFrame(animate);\n                }\n                render();\n            }\n\n            function makeCanvasFullScreen(canvas: any) {\n                var b: any = document.body;\n                var d: any = document.documentElement;\n                let fullw = Math.max(\n                    b.clientWidth,\n                    b.scrollWidth,\n                    d.scrollWidth,\n                    d.clientWidth\n                );\n                let fullh = Math.max(\n                    b.clientHeight,\n                    b.scrollHeight,\n                    d.scrollHeight,\n                    d.clientHeight\n                );\n                canvas.width = fullw;\n                canvas.height = fullh;\n            }\n\n            // 保证每次都执行\n            var canvas: any = document.getElementById(\"sakura\");\n            try {\n                makeCanvasFullScreen(canvas);\n                gl = canvas.getContext(\"experimental-webgl\");\n            } catch (e) {\n                alert(\"WebGL not supported.\" + e);\n                console.error(e);\n                return;\n            }\n\n            window.addEventListener(\"resize\", onResize);\n\n            setViewports();\n            createScene();\n            initScene();\n\n            timeInfo.start = new Date();\n            timeInfo.prev = timeInfo.start;\n            animate();\n\n            //set window.requestAnimationFrame\n            (function(w: any, r: any) {\n                w[\"r\" + r] =\n                    w[\"r\" + r] ||\n                    w[\"webkitR\" + r] ||\n                    w[\"mozR\" + r] ||\n                    w[\"msR\" + r] ||\n                    w[\"oR\" + r] ||\n                    function(c: any) {\n                        w.setTimeout(c, 1000 / 60);\n                    };\n            })(window, \"equestAnimationFrame\");\n        }\n    }\n</script>\n\n<style lang=\"less\" scoped>\n\n</style>\n"]}]}